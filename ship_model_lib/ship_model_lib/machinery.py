# AUTOGENERATED! DO NOT EDIT! File to edit: ../03_Machinery.ipynb.

# %% auto 0
__all__ = [
    "Numeric",
    "Point",
    "Curve",
    "FuelByMassFraction",
    "FuelConsumption",
    "Emissions",
    "EmissionFactor",
    "LoadInput",
    "MachineryResult",
    "MachinerySystemResult",
    "PowerSource",
    "PowerSourceWithEfficiency",
    "PowerSourceWithSpecificFuelConsumption",
    "PowerLoad",
    "MachinerySubsystemSimple",
    "MachinerySystem",
]

# %% ../03_Machinery.ipynb 4
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from functools import cached_property
from typing import Optional, Union, Callable, List, TypeVar, NamedTuple
import numpy as np
from plotly.subplots import make_subplots
from plotly.graph_objs import Figure as PlotlyFigure
from ship_model_lib.utility import get_interpolation_1d_function, Interpolated1DValue
from .types import PropulsionType, EmissionType

Numeric = TypeVar("Numeric", np.ndarray, float)


@dataclass
class Point:
    x: float
    y: float


@dataclass
class Curve:
    points: List[Point] = field(default_factory=list)

    def add_point(self, point: Point):
        self.points.append(point)

    def to_x_array(self) -> np.ndarray:
        return np.array([point.x for point in self.points])

    def to_y_array(self) -> np.ndarray:
        return np.array([point.y for point in self.points])

    def get_curve_plot(
        self,
        name: str = "",
        y_label: Optional[str] = None,
        x_label: Optional[str] = None,
    ) -> PlotlyFigure:
        fig = make_subplots()
        fig.add_scatter(x=self.to_x_array(), y=self.to_y_array(), name=name)
        if x_label is not None:
            fig.update_xaxes(title=x_label)
        if y_label is not None:
            fig.update_yaxes(title=y_label)
        return fig


@dataclass
class FuelByMassFraction:
    diesel: float = 0.0
    hfo: float = 0.0
    natural_gas: float = 0.0
    hydrogen: float = 0.0
    ammonia: float = 0.0
    lpg: float = 0.0
    marine_gas_oil: float = 0.0
    methanol: float = 0.0
    _LHV_DIESEL: float = 42.7
    _LHV_HFO: float = 40.8
    _LHV_NG: float = 47.3
    _LHV_Hydrogen: float = 120.0
    _LHV_Ammonia: float = 18.6
    _LHV_LPG: float = 45.5
    _LHV_MGO: float = 42.8
    _LHV_Methanol: float = 19.9
    _CO2_DIESEL: float = 3.15
    _CO2_HFO: float = 3.11
    _CO2_NG: float = 2.75
    _CO2_Hydrogen: float = 0.0
    _CO2_Ammonia: float = 0.0
    _CO2_LPG: float = 3.01
    _CO2_MGO: float = 3.15
    _CO2_Methanol = 1.37
    # kg CO2 / kg fuel from engineeringtoolbox.com

    def __post_init__(self):
        total_fraction = sum(
            [
                getattr(self, fuel_type)
                for fuel_type in self.__dict__
                if not fuel_type.startswith("_")
            ]
        )
        assert total_fraction == 1.0, "The mass fraction must sum to 1."

    @property
    def lhv_mj_per_kg(self):
        """
        Returns the low heat value of fuel based on fuel mass fraction
        """
        return (
            self.diesel * self._LHV_DIESEL
            + self.hfo * self._LHV_HFO
            + self.natural_gas * self._LHV_NG
            + self._LHV_Hydrogen * self.hydrogen
            + self._LHV_Ammonia * self.ammonia
            + self._LHV_LPG * self.lpg
            + self._LHV_MGO * self.marine_gas_oil
            + self._LHV_Methanol * self.methanol
        )

    def get_co_2_curve(self, efficiency: Curve) -> Curve:
        kg_co2_per_kg_fuel = (
            self.diesel * self._CO2_DIESEL
            + self.hfo * self._CO2_HFO
            + self.natural_gas * self._CO2_NG
            + self.hydrogen * self._CO2_Hydrogen
            + self.ammonia * self._CO2_Ammonia
            + self.lpg * self._CO2_LPG
            + self.marine_gas_oil * self._CO2_MGO
            + self.methanol * self._CO2_Methanol
        )
        kg_co2_per_kwh = 1 / (self.lhv_mj_per_kg / 3.6) * kg_co2_per_kg_fuel
        co_2_points = []
        for point in efficiency.points:
            g_co2_per_kwh_shaft = kg_co2_per_kwh * 1000 / point.y
            co_2_points.append(Point(x=point.x, y=g_co2_per_kwh_shaft))
        return Curve(co_2_points)


class FuelConsumption:
    diesel: float = 0.0
    hfo: float = 0.0
    natural_gas: float = 0.0
    hydrogen: float = 0.0
    ammonia: float = 0.0
    lpg: float = 0.0
    marine_gas_oil: float = 0.0
    methanol: float = 0.0

    def __init__(
        self, total_fuel_consumption: float, fuel_by_mass_fraction: FuelByMassFraction
    ):
        self.diesel = fuel_by_mass_fraction.diesel * total_fuel_consumption
        self.hfo = fuel_by_mass_fraction.hfo * total_fuel_consumption
        self.natural_gas = fuel_by_mass_fraction.natural_gas * total_fuel_consumption
        self.hydrogen = fuel_by_mass_fraction.hydrogen * total_fuel_consumption
        self.ammonia = fuel_by_mass_fraction.ammonia * total_fuel_consumption
        self.lpg = fuel_by_mass_fraction.lpg * total_fuel_consumption
        self.marine_gas_oil = (
            fuel_by_mass_fraction.marine_gas_oil * total_fuel_consumption
        )
        self.methanol = fuel_by_mass_fraction.methanol * total_fuel_consumption

    def __add__(self, other):
        # Create a new FuelConsumption object with zero fuel consumption
        sum_fuel = FuelConsumption(
            total_fuel_consumption=0,
            fuel_by_mass_fraction=FuelByMassFraction(diesel=1.0),
        )
        for fuel in self.__dict__.keys():
            sum_fuel.__setattr__(
                fuel, self.__getattribute__(fuel) + other.__getattribute__(fuel)
            )
        return sum_fuel

    @property
    def total_fuel_consumption(self):
        """Returns the total fuel consumption in kg/h"""
        return (
            self.diesel
            + self.hfo
            + self.natural_gas
            + self.hydrogen
            + self.ammonia
            + self.lpg
            + self.marine_gas_oil
            + self.methanol
        )


@dataclass
class Emissions:
    co2: float = 0.0
    sox: float = 0.0
    nox: float = 0.0
    pm: float = 0.0

    def __add__(self, other):
        return Emissions(
            co2=self.co2 + other.co2,
            sox=self.sox + other.sox,
            nox=self.nox + other.nox,
            pm=self.pm + other.pm,
        )


@dataclass
class EmissionFactor:
    rated_power_kw: float
    factor: Union[Curve, float]
    emission_type: EmissionType

    @property
    def has_scalar_factor(self) -> bool:
        return isinstance(self.factor, float)

    @cached_property
    def interpolate_factor(self) -> Callable[[Numeric], Interpolated1DValue]:
        return get_interpolation_1d_function(
            x=self.factor.to_x_array(), y=self.factor.to_y_array(), add_origo=False
        )

    def get_emission_kg_per_h(self, power_kw: Numeric) -> Numeric:
        power_normalized = power_kw / self.rated_power_kw
        if self.has_scalar_factor:
            return self.factor * power_kw / 1000
        return self.interpolate_factor(power_normalized).value * power_kw / 1000

    def get_emission_plot(self) -> Optional[PlotlyFigure]:
        """Returns a plot of the emission factor. Returns None if the emission factor is a scalar"""
        if self.has_scalar_factor:
            return None
        return self.factor.get_curve_plot(
            name=f"{self.emission_type.name} emission factor",
            y_label="Emission factor [g/kWh]",
            x_label="Power [p.u.]",
        )


@dataclass
class LoadInput:
    """class for load input"""

    propulsion_load_kw: Numeric = 0
    auxiliary_load_kw: Numeric = 0


class MachineryResult(NamedTuple):
    """Result of machinery calculation for fuel consumption and emissions"""

    power_on_source_kw: Numeric = 0
    fuel_consumption: FuelConsumption = FuelConsumption(
        total_fuel_consumption=0, fuel_by_mass_fraction=FuelByMassFraction(diesel=1.0)
    )
    emissions: Emissions = Emissions()

    def __add__(self, other):
        """Adds two machinery results.

        You can use + operator to add two machinery results with this function defined.

        Example:
            >>> result1 = MachineryResult(
            >>>     power_kw=100,
            >>>     fuel_consumption=FuelConsumption(100, FuelByMassFraction(diesel=1.0))
            >>> )
            >>> result2 = MachineryResult(
            >>>     power_kw=80,
            >>>     fuel_consumption=FuelConsumption(80, FuelByMassFraction(diesel=1.0))
            >>> )
            >>> total_result = result1 + result2
        """
        return MachineryResult(
            power_on_source_kw=self.power_on_source_kw + other.power_on_source_kw,
            fuel_consumption=self.fuel_consumption + other.fuel_consumption,
            emissions=self.emissions + other.emissions,
        )


class MachinerySystemResult(NamedTuple):
    """Result of machinery system calculation for fuel consumption and emissions"""

    total: MachineryResult
    mechanical_system: Optional[MachineryResult] = None
    electric_system: Optional[MachineryResult] = None


# %% ../03_Machinery.ipynb 11
@dataclass(kw_only=True)
class PowerSource(ABC):
    fuel: FuelByMassFraction
    rated_power_kw: float
    emission_factors: List[EmissionFactor] = field(default_factory=list)

    @abstractmethod
    def get_specific_fuel_consumption_g_per_kwh(
        self, power_out_kw: Optional[Numeric] = None
    ) -> Numeric:
        pass

    def get_fuel_consumption_kg_per_h(self, power_out_kw: float) -> FuelConsumption:
        """Returns the fuel consumption (kg/h)"""
        total_fuel_consumption_kg_per_h = (
            self.get_specific_fuel_consumption_g_per_kwh(power_out_kw=power_out_kw)
            * power_out_kw
            / 1000
        )
        return FuelConsumption(
            total_fuel_consumption=total_fuel_consumption_kg_per_h,
            fuel_by_mass_fraction=self.fuel,
        )

    def get_emissions_kg_per_h(self, power_out_kw: float) -> Emissions:
        """Returns the emissions (kg/h)"""
        emissions = Emissions()
        for emission_factor in self.emission_factors:
            emissions.__setattr__(
                emission_factor.emission_type.value,
                emission_factor.get_emission_kg_per_h(power_out_kw),
            )
        return emissions

    def get_machinery_result(self, power_out_kw: float) -> MachineryResult:
        return MachineryResult(
            power_on_source_kw=power_out_kw,
            fuel_consumption=self.get_fuel_consumption_kg_per_h(power_out_kw),
            emissions=self.get_emissions_kg_per_h(power_out_kw),
        )


@dataclass(kw_only=True)
class PowerSourceWithEfficiency(PowerSource):
    """Power source with efficiency as a scalar or a curve

    The efficiency can be a scalar or a curve. When it is a curve, x is power output that is
    normalized to the rated power of the power source, and y is the efficiency.
    """

    efficiency: Union[float, Curve]

    @property
    def _has_scalar_efficiency(self):
        return isinstance(self.efficiency, float) or isinstance(self.efficiency, int)

    @cached_property
    def _engine_efficiency_curve_interpolator(self):
        """
        Interpolates the engine efficiency based on output load-efficiency curve in a specific load.
        This is independent of the engine speed.
        """
        assert (
            not self._has_scalar_efficiency
        ), "Engine efficiency is a scalar, not a curve."
        return get_interpolation_1d_function(
            x=self.efficiency.to_x_array(),
            y=self.efficiency.to_y_array(),
            add_origo=False,
        )

    def get_specific_fuel_consumption_g_per_kwh(
        self, power_out_kw: Optional[Numeric] = None
    ) -> Numeric:
        """
        Returns the specific fuel consumption of engine (g/kw.h)
        """
        if self._has_scalar_efficiency:
            return 1 / self.efficiency / self.fuel.lhv_mj_per_kg * 3600
        else:
            shaft_power_normalized = power_out_kw / self.rated_power_kw
            efficiency = self._engine_efficiency_curve_interpolator(
                shaft_power_normalized
            ).value
            return 1 / efficiency / self.fuel.lhv_mj_per_kg * 3600


@dataclass(kw_only=True)
class PowerSourceWithSpecificFuelConsumption(PowerSource):
    """Power source with a specific fuel consumption defined as a scalar or a curve

    The specific fuel consumption is defined as g/kWh. It can be a scalar or a curve.
    If it is a curve, the curve is defined as a function of the power output normalized
    by the rated power.
    """

    specific_fuel_consumption: Union[float, Curve]

    @property
    def _has_scalar_specific_fuel_consumption(self):
        return isinstance(self.specific_fuel_consumption, float) or isinstance(
            self.specific_fuel_consumption, int
        )

    @cached_property
    def _specific_fuel_consumption_curve_interpolator(self):
        """
        Interpolates the specific fuel consumption based on input load-specific fuel consumption
        curve in a specific load. This is independent of the engine speed.
        """
        assert (
            not self._has_scalar_specific_fuel_consumption
        ), "Specific fuel consumption is a scalar, not a curve."
        return get_interpolation_1d_function(
            x=self.specific_fuel_consumption.to_x_array(),
            y=self.specific_fuel_consumption.to_y_array(),
            add_origo=False,
        )

    def get_specific_fuel_consumption_g_per_kwh(
        self, power_out_kw: Optional[Numeric] = None
    ) -> Numeric:
        """
        Returns the specific fuel consumption of engine (g/kwh)
        """
        if self._has_scalar_specific_fuel_consumption:
            return self.specific_fuel_consumption
        else:
            shaft_power_normalized = power_out_kw / self.rated_power_kw
            return self._specific_fuel_consumption_curve_interpolator(
                shaft_power_normalized
            ).value


@dataclass
class PowerLoad:
    """class for load in a MachinerySubsystemSimple

    When the efficiency is given a scalar, it should be a value between 0 and 1. If it is a curve,
    the x-axis should be the load (power out / rated power, 0~1) and the y-axis should be the
    efficiency (0~1). When the efficiency is a curve, rated power should be defined.
    """

    efficiency: Union[float, Curve]
    rated_power_kw: Optional[float] = None

    def __post_init__(self):
        """Check if the efficiency is a scalar or a curve"""
        if not self._has_scalar_efficiency and self.rated_power_kw is None:
            raise ValueError(
                "Rated power should be defined when efficiency is a curve."
            )

    @property
    def _has_scalar_efficiency(self):
        """Check if the efficiency is a scalar or a curve"""
        return isinstance(self.efficiency, float) or isinstance(self.efficiency, int)

    @cached_property
    def _efficiency_curve_interpolator(self):
        """
        Interpolates the efficiency based on output load-efficiency curve in a specific load.
        This is independent of the engine speed.
        """
        assert not self._has_scalar_efficiency, "Efficiency is a scalar, not a curve."
        return get_interpolation_1d_function(
            x=self.efficiency.to_x_array(),
            y=self.efficiency.to_y_array(),
            add_origo=False,
        )

    def get_efficiency(self, power_out_kw: Numeric) -> Numeric:
        """Returns the internal efficiency of the load"""
        if self._has_scalar_efficiency:
            return self.efficiency
        else:
            return self._efficiency_curve_interpolator(
                power_out_kw / self.rated_power_kw
            ).value

    def get_power_in_kw(self, power_out_kw: Numeric) -> Numeric:
        """Returns the power input to the load from power output"""
        return power_out_kw / self.get_efficiency(power_out_kw)


# %% ../03_Machinery.ipynb 17
@dataclass
class MachinerySubsystemSimple:
    """Simple machinery subsystem

    A simple machinery subsystem has a single power source and two power loads.
    One power load is the propulsion load, and the other is the auxiliary load
    (or all other loads other than propulsion).

    The intention is to distinguish between the propulsion load and the other loads.
    Propulsion load is the shaft power of the propeller and the other loads are the
    power consumption at the switchboard or a main shaft.
    """

    power_source: Union[
        PowerSourceWithEfficiency, PowerSourceWithSpecificFuelConsumption
    ]
    propulsion_load: PowerLoad = None
    auxiliary_load: PowerLoad = None

    def get_machinery_result(self, load: LoadInput) -> MachineryResult:
        """Returns the machinery result"""
        propulsion_load_on_power_source = (
            self.propulsion_load.get_power_in_kw(load.propulsion_load_kw)
            if self.propulsion_load is not None
            else 0
        )
        aux_load_on_power_source = (
            self.auxiliary_load.get_power_in_kw(load.auxiliary_load_kw)
            if self.auxiliary_load is not None
            else 0
        )
        total_power_on_power_source = (
            propulsion_load_on_power_source + aux_load_on_power_source
        )
        return self.power_source.get_machinery_result(total_power_on_power_source)


@dataclass
class MachinerySystem:
    """Class for a machinery system

    The machinery system is consisted of two machinery subsystems: one is the mechanical system
    and the other is the electric system. If the propulsion type is `mechanical`, the electric
    system represents the auxiliary power system whereas the mechanical system represents the
    propulsion system. If the propulsion type is `electric`, the electric system represents both
    whereas the mechanical system should be None.
    """

    propulsion_type: PropulsionType
    mechanical_system: MachinerySubsystemSimple = None
    electric_system: MachinerySubsystemSimple = None

    def __post_init__(self):
        if (
            self.propulsion_type == PropulsionType.MECHANICAL
            and self.mechanical_system is None
        ):
            raise ValueError(
                "Mechanical system should be defined when propulsion type is "
                "mechanical."
            )
        if (
            self.propulsion_type == PropulsionType.ELECTRIC
            and self.electric_system is None
            and self.mechanical_system is not None
        ):
            raise ValueError(
                "Electric system should be defined when propulsion type is " "electric."
            )

    @property
    def has_mechanical_system(self):
        return self.mechanical_system is not None

    @property
    def has_electric_system(self):
        return self.electric_system is not None

    def get_machinery_result(
        self,
        mechanical_load: Optional[LoadInput] = None,
        electric_load: Optional[LoadInput] = None,
    ) -> MachinerySystemResult:
        """Returns the machinery result which contains fuel consumption and power consumption at
        the power source for each subsystem and total.

        If the propulsion type is `mechanical`, the mechanical load should be given with the
        propulsion load whereas the electric load should be given only with the auxiliary load.
        If the propulsion type is `electric`, the electric load should be given with both the
        propulsion load and the auxiliary load. The mechanical load should not be given.
        """
        # Check if the subsystem is defined for the power inputs
        if mechanical_load is not None and not self.has_mechanical_system:
            raise TypeError("Mechanical system is not defined")
        if electric_load is not None and not self.has_electric_system:
            raise TypeError(
                "Electric system is not defined but electric load is given."
            )
        if (
            self.propulsion_type == PropulsionType.MECHANICAL
            and electric_load is not None
            and electric_load.propulsion_load_kw > 0
        ):
            raise ValueError(
                "Propulsion load should not be given with the electric load when "
                "propulsion type is mechanical."
            )

        # Setting the default values with null values
        result_mechanical = MachineryResult()
        result_electric = MachineryResult()

        # Calculate fuel consumption for mechanical system
        if self.has_mechanical_system:
            assert mechanical_load is not None, (
                "Mechanical consumer power must be provided if the machinery system "
                "has a mechanical system."
            )
            result_mechanical = self.mechanical_system.get_machinery_result(
                mechanical_load
            )

        # Calculate fuel consumption for electric system
        if self.has_electric_system:
            assert electric_load is not None, (
                "Electric consumer power must be provided "
                "if the machinery system has an electric system."
            )
            result_electric = self.electric_system.get_machinery_result(electric_load)
        if not self.has_mechanical_system and not self.has_electric_system:
            raise TypeError("Machinery system is not defined")

        return MachinerySystemResult(
            mechanical_system=result_mechanical,
            electric_system=result_electric,
            total=result_mechanical + result_electric,
        )
